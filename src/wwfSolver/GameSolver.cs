using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.Diagnostics;

namespace wwfSolver
{
    public class GameSolver
    {
        

        private WordDict mWordDict;
        private char[,] mBoardLetters;
        private char[] mAvailableLetters;
        private List<int> mUsedLetterIdxs = new List<int>();
        private List<LetterLoc> mCurrentWord = new List<LetterLoc>();

        
        
        

        public GameSolver(WordDict wordDict, char[,] boardLetters, char[] availableLetters)
        {
            mWordDict = wordDict;
            mBoardLetters = boardLetters;
            mAvailableLetters = availableLetters;
        }

        public SortedDictionary<int, LetterLoc[]> GetSolutions()
        {
            SortedDictionary<int, LetterLoc[]> solutions = new SortedDictionary<int, LetterLoc[]>();

            for (int i = 0; i < GameVals.BOARD_SIZE; i++)
            {
                for (int j = 0; j < GameVals.BOARD_SIZE; j++)
                {
                    if (LocationContainsLetter(i, j))
                    {
                        continue;
                    }

                    for (int letterIdx = 0; letterIdx < GameVals.AVAILABLE_LETTER_MAX; letterIdx++)
                    {
                        if (mUsedLetterIdxs.Contains(letterIdx))
                        {
                            continue;
                        }

                        //we have a letter and a location to try out
                        char letter = mAvailableLetters.ElementAt(letterIdx);
                        
                        //evaluate legality of move
                        if (!IsLegalMove(i, j))
                        {
                            mBoardLetters[i, j] = ' ';
                            continue;
                        }

                        LetterLoc curLetterLoc = new LetterLoc(letter, i, j);
                        mBoardLetters[i, j] = letter;
                        mCurrentWord.Add(curLetterLoc);                        
                        mUsedLetterIdxs.Add(letterIdx);

                        string illegalWord;
                        int score = GetWordScore(out illegalWord);
                        if (score < 0)
                        {
                            Console.Out.WriteLine("Illegal word: " + illegalWord);

                            //remove letter from board
                            mBoardLetters[i, j] = ' ';
                            mUsedLetterIdxs.Remove(letterIdx);
                            mCurrentWord.Remove(curLetterLoc);
                        }
                        else
                        {
                            LetterLoc[] solution = new LetterLoc[mCurrentWord.Count];
                            mCurrentWord.CopyTo(solution);
                            solutions.Add(score, solution);
                        }
                     }
                }
            }

            return solutions;
        }

        private int GetWordScore(out string illegalWord)
        {
            illegalWord = null;
            int score = 0;

            //for each letter in the proposed word, add the score of any new words generated by that letter
            foreach (LetterLoc letter in mCurrentWord)
            {
                //evaluate in X direction
                int initX = letter.X;
                int minX = initX;
                for (int i = initX; i >= 0; i--)
                {
                    if (mBoardLetters[i, letter.Y] == ' ')
                    {
                        break;
                    }
                    else
                    {
                        minX = i;
                    }
                }

                int maxX = initX;
                for (int i = initX; i < GameVals.BOARD_SIZE; i++)
                {
                    if (mBoardLetters[i, letter.Y] == ' ')
                    {
                        break;
                    }
                    else
                    {
                        maxX = i;
                    }
                }

                int wordLenX = maxX - minX + 1;
                if (wordLenX > 1)
                {
                    //get word
                    string word = "";
                    for (int i = minX; i <= maxX; i++)
                    {
                        word += mBoardLetters[i, letter.Y];
                    }

                    //first check for legal word
                    if (!mWordDict.IsWordInList(word))
                    {
                        illegalWord = word;
                        return -1;
                    }

                    //score the word
                    int wordScore = 0;
                    int multipliers = 1;
                    for (int i = minX; i <= maxX; i++)
                    {
                        char letterChar =  mBoardLetters[i, letter.Y];
                        int letterScore = GameVals.LETTER_SCORE[letterChar];
                        GameVals.Bonus letterBonus = GameVals.BONUS_TILES[i, letter.Y];
                        switch (letterBonus)
                        {
                            case GameVals.Bonus.D_LT:
                                letterScore *= 2;
                                break;
                            case GameVals.Bonus.T_LT:
                                letterScore *= 3;
                                break;
                            case GameVals.Bonus.D_WD:
                                multipliers *= 2;
                                break;
                            case GameVals.Bonus.T_WD:
                                multipliers *= 3;
                                break;
                        }

                        wordScore += letterScore;
                    }
                    wordScore *= multipliers;

                    score += wordScore;
                }



                //evaluate in Y direction
                int initY = letter.Y;
                int minY = initY;
                for (int j = initY; j >= 0; j--)
                {
                    if (mBoardLetters[letter.X, j] == ' ')
                    {
                        break;
                    }
                    else
                    {
                        minY = j;
                    }
                }

                int maxY = initY;
                for (int j = initY; j < GameVals.BOARD_SIZE; j++)
                {
                    if (mBoardLetters[letter.X, j] == ' ')
                    {
                        break;
                    }
                    else
                    {
                        maxY = j;
                    }
                }

                int wordLenY = maxY - minY + 1;
                if (wordLenY > 1)
                {
                    //get word
                    string word = "";
                    for (int j = minY; j <= maxY; j++)
                    {
                        word += mBoardLetters[letter.X, j];
                    }

                    //first check for legal word
                    if (!mWordDict.IsWordInList(word))
                    {
                        illegalWord = word;
                        return -1;
                    }

                    //score the word
                    int wordScore = 0;
                    int multipliers = 1;
                    for (int j = minY; j <= maxY; j++)
                    {
                        char letterChar = mBoardLetters[letter.X, j];
                        int letterScore = GameVals.LETTER_SCORE[letterChar];
                        GameVals.Bonus letterBonus = GameVals.BONUS_TILES[letter.X, j];
                        switch (letterBonus)
                        {
                            case GameVals.Bonus.D_LT:
                                letterScore *= 2;
                                break;
                            case GameVals.Bonus.T_LT:
                                letterScore *= 3;
                                break;
                            case GameVals.Bonus.D_WD:
                                multipliers *= 2;
                                break;
                            case GameVals.Bonus.T_WD:
                                multipliers *= 3;
                                break;
                        }

                        wordScore += letterScore;
                    }
                    wordScore *= multipliers;

                    score += wordScore;
                }
            }


            return score;
        }

        private bool IsLegalMove(int x, int y)
        {
            //look at whether location is in-line with current word
            if (mCurrentWord.Count > 0)
            {
                int initX = mCurrentWord[0].X;
                int initY = mCurrentWord[0].Y;

                //location is not in line with existing current word
                if (x != initX || y != initY)
                {
                    return false;
                }

                if (x == initX)
                {
                    //make sure there is a letter between InitX and X
                    int smallerX = Math.Min(x, initX);
                    int largerX = Math.Max(x, initX);
                    for (int i = smallerX + 1; i < largerX; i++)
                    {
                        if (!LocationContainsLetter(i, y))
                        {
                            return false;
                        }
                    }
                }
                else if (y == initY)
                {
                    //make sure there is a letter between InitY and Y
                    int smallerY = Math.Min(y, initY);
                    int largerY = Math.Max(y, initY);
                    for (int j = smallerY + 1; j < largerY; j++)
                    {
                        if (!LocationContainsLetter(x, j))
                        {
                            return false;
                        }
                    }
                }
            }
            else
            {
                //this is the first move; make sure it is adjacent to a cell
                if (x > 0 && mBoardLetters[x - 1, y] != ' ')
                    return true;
                if (x < GameVals.BOARD_SIZE - 1 && mBoardLetters[x + 1, y] != ' ')
                    return true;

                if (y > 0 && mBoardLetters[x, y - 1] != ' ')
                    return true;
                if (y < GameVals.BOARD_SIZE - 1 && mBoardLetters[x, y + 1] != ' ')
                    return true;

                return false; //not adjacent to any tiles already on board
            }

            return true;
        }


        private bool LocationContainsLetter(int x, int y)
        {
            //look at board location
            if (mBoardLetters[x, y] != ' ')
            {
                return true;
            }

            return false;
        }
    }

    //public class WordSolution
    //{
    //    private List<LetterLoc> mLetters = new List<LetterLoc>();

    //    public WordSolution()
    //    {
    //    }

    //    public void AddLetter(LetterLoc letter)
    //    {
    //        mLetters.Add(letter);
    //    }

    //    public List<LetterLoc> Word
    //    {
    //        get { return mLetters; }
    //    }
    //}

    public struct LetterLoc
    {
        public readonly char Letter;
        public readonly int X;
        public readonly int Y;

        public LetterLoc(char letter, int x, int y)
        {
            Letter = letter;
            X = x;
            Y = y;
        }
    }
}
